PART 1:
-------------------

1. The Towers of Hanoi was solved in all three languages: C++, Java and Python. All three languages follow the same implementation. The C++ and Java versions are almost identically implemented, while the Python version had to be changed a bit logically due to the major difference in syntax. Nevertheless, all three programs solve the problem with the same recursive procedure. The output of all three programs are identical for n number of disks. All three programs were compiled and tested on different platforms. The output of all three versions has proven to remain consistant across platforms.

2. Since I am strongest with C++, I found that the easiest to use. C++ is very percise, and therefore I can be more flexible with how I want to implement the solution. Therefore, I used the C++ program to craft the best solution logically, and the I used the perfected C++ program to implement the Java and Pyton versions. The Java version was implemented almost identically as the C++ version. The few "gotchas" with the Java version were that the stack.top() action was instead stack.peek(), and that you need to use stack.clone() if you want to make a copy of stack without it pointing to the original stack. The one benifit that the Java language had over the C++ language when implementing Stack data structures was that in Java, stack.pop() returns the next element on the stack while that is not the case in C++.


PART 2:
-------------------

1. There are several different ways to solve the Towers of Hanoi. One way this can be solved is by iteration, whereby disks are moved between the smallest piece and non-smallest piece of a n-tower set. Secondly, recursion can be used to solve this, as was implemented in this assignment. Recursion showed that this problem could be split up into n/2 smaller problems, and each of the individual subproblems can be combined to form a final solution. Other ways to solve this problem include a binary solution, where the disks and towers are represented by binary digits, one digit per tower. Lastly, Gray Code solutions are also known.

2. My recursive solution went like this: If the size of the source stack is equal to 1, move the one element on the stack to the destination stack. If the size of the source stack is not equal to 1, the moveDisks method will be called recursively first by decrementing the initial source stack_size variable, then by making the destination the storage (auxiliary) stack vice versa for the storage stack. Once returned from that recursive call, the top element from the source stack will be moved to the destination stack. Lastly, the recursive procedure is called again with a further decremented stack_size and the storage stack as the source stack and vice versa for the source stack.
In terms of time and space complexity, since a function in the program calls itself n - 1 times, the upper bound for the  time complexity is O(2^n) by the Divide and Conquer strategy for analyzing algorithms (T(n) = 2T(n-1) + 1). However, in all three programs the stacks are passed by reference, so each recursive call does not keep taking up more space. Therefore, O(2^n) units of stack space is required for the algorithm to run, due to multiple function calls, but since other variables are passed by reference, additional space is not a big factor in the space complexity.

3. Since my solution uses recursion, as n increases, the amount of stack space to be reserved increases and therefore the efficiency of the program depricates. Binary or iterative solutions appear to run in linear time, so it is possible that those implementations could be more efficient, but I have not spent much time looking into that. In terms of how efficient my recursive solution is by comparison to others out there, I would say it is comparable, if not the same. The hints provided by the instructor directly map to known solutions that are online. Therefore, the efficiency of my solution should not differ drastically from the main known recursive solutions.

4. I think that a Stack data structure makes the most sense for this problem, since physically the problem is a stack. Other ways of implementing the problem with different data structures further abstracts the problem. However, array data structures such as ArrayList make sense for this problem. However, data structures such as binary trees or sets would not make much sense.